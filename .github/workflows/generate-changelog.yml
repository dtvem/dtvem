name: Generate Changelog

on:
  workflow_call:
    outputs:
      changelog:
        description: "The generated changelog content"
        value: ${{ jobs.generate.outputs.changelog }}

jobs:
  generate:
    name: Generate Changelog
    runs-on: ubuntu-latest
    outputs:
      changelog: ${{ steps.changelog.outputs.CHANGELOG }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Fetch all history for changelog generation

    - name: Generate changelog
      id: changelog
      run: |
        # Get previous release tag
        # NOTE: This must run BEFORE creating the new tag, otherwise git describe
        # will find the new tag and the changelog will be empty
        PREVIOUS_TAG=$(git describe --abbrev=0 --tags --match "v*" 2>/dev/null || echo "")

        echo "Previous tag: ${PREVIOUS_TAG:-'(none - first release)'}"

        # Get commit data since last release
        if [ -z "$PREVIOUS_TAG" ]; then
          COMMIT_RANGE="HEAD"
        else
          COMMIT_RANGE="${PREVIOUS_TAG}..HEAD"
        fi

        # Collect highlights from PR comments and categorize commits
        # Each category stores entries with issue number prefix for sorting: "NNNN|entry"
        declare -a HIGHLIGHTS
        declare -a BUGS           # fix
        declare -a IMPROVEMENTS   # perf, refactor
        declare -a FEATURES       # feat
        declare -a MAINTENANCE    # docs, style, test, build, ci, chore
        declare -a OTHER          # anything else (except revert which is omitted)

        # Get list of commit SHAs
        COMMIT_SHAS=$(git log ${COMMIT_RANGE} --pretty=format:"%H" --no-merges)

        # Track processed PRs to avoid duplicates
        declare -A PROCESSED_PRS

        # Process each commit
        for SHA in $COMMIT_SHAS; do
          echo "Processing commit: $SHA"

          # Find the PR associated with this commit
          PR_DATA=$(gh pr list --search "$SHA" --state merged --json number,title --limit 1 2>/dev/null || echo "[]")

          if [ "$PR_DATA" = "[]" ] || [ -z "$PR_DATA" ]; then
            echo "  No PR found, skipping"
            continue
          fi

          PR_NUMBER=$(echo "$PR_DATA" | jq -r '.[0].number // empty')
          PR_TITLE=$(echo "$PR_DATA" | jq -r '.[0].title // empty')

          if [ -z "$PR_NUMBER" ] || [ -z "$PR_TITLE" ]; then
            echo "  Could not get PR details, skipping"
            continue
          fi

          # Skip if we've already processed this PR
          if [ -n "${PROCESSED_PRS[$PR_NUMBER]}" ]; then
            echo "  PR #$PR_NUMBER already processed, skipping"
            continue
          fi
          PROCESSED_PRS[$PR_NUMBER]=1

          echo "  Found PR #$PR_NUMBER: $PR_TITLE"

          # Skip revert PRs
          if echo "$PR_TITLE" | grep -qE "^revert(\(|:)"; then
            echo "  Skipping revert PR"
            continue
          fi

          # Check PR comments for commands
          PR_COMMENTS=$(gh pr view "$PR_NUMBER" --json comments --jq '.comments[].body' 2>/dev/null || echo "")

          # Check for /skip-changelog command
          if echo "$PR_COMMENTS" | grep -q "^/skip-changelog"; then
            echo "  Found /skip-changelog, skipping PR"
            continue
          fi

          # Check for /release-note command
          RELEASE_NOTE=$(echo "$PR_COMMENTS" | grep "^/release-note " | sed 's|^/release-note ||' | head -1 || echo "")
          if [ -n "$RELEASE_NOTE" ]; then
            echo "  Found /release-note: $RELEASE_NOTE"
            HIGHLIGHTS+=("$RELEASE_NOTE")
          fi

          # Build entry using PR number and title
          ENTRY="- #${PR_NUMBER} - $PR_TITLE"

          # Store with PR number prefix for sorting
          SORTABLE_ENTRY="${PR_NUMBER}|${ENTRY}"

          # Categorize by conventional commit prefix in PR title
          if echo "$PR_TITLE" | grep -qE "^fix(\(|:)"; then
            BUGS+=("$SORTABLE_ENTRY")
          elif echo "$PR_TITLE" | grep -qE "^(perf|refactor)(\(|:)"; then
            IMPROVEMENTS+=("$SORTABLE_ENTRY")
          elif echo "$PR_TITLE" | grep -qE "^feat(\(|:)"; then
            FEATURES+=("$SORTABLE_ENTRY")
          elif echo "$PR_TITLE" | grep -qE "^(docs|style|test|build|ci|chore)(\(|:)"; then
            MAINTENANCE+=("$SORTABLE_ENTRY")
          else
            OTHER+=("$SORTABLE_ENTRY")
          fi
        done

        # Helper function to sort entries by issue number and format output
        sort_entries() {
          local -n arr=$1
          if [ ${#arr[@]} -gt 0 ]; then
            printf '%s\n' "${arr[@]}" | sort -t'|' -k1 -n | cut -d'|' -f2-
          fi
        }

        # Build changelog
        CHANGELOG=""

        # Add Highlights section if any /release-note entries exist
        if [ ${#HIGHLIGHTS[@]} -gt 0 ]; then
          CHANGELOG="### ‚ú® Highlights"$'\n\n'
          for HIGHLIGHT in "${HIGHLIGHTS[@]}"; do
            CHANGELOG="${CHANGELOG}- ${HIGHLIGHT}"$'\n'
          done
          CHANGELOG="${CHANGELOG}"$'\n'
        fi

        # Add categorized sections in order: Bug Fixes, Performance & Improvements, New Features, Maintenance, Other
        if [ ${#BUGS[@]} -gt 0 ]; then
          CHANGELOG="${CHANGELOG}### üêõ Bug Fixes"$'\n\n'
          while IFS= read -r entry; do
            CHANGELOG="${CHANGELOG}${entry}"$'\n'
          done < <(sort_entries BUGS)
          CHANGELOG="${CHANGELOG}"$'\n'
        fi

        if [ ${#IMPROVEMENTS[@]} -gt 0 ]; then
          CHANGELOG="${CHANGELOG}### ‚ö° Performance & Improvements"$'\n\n'
          while IFS= read -r entry; do
            CHANGELOG="${CHANGELOG}${entry}"$'\n'
          done < <(sort_entries IMPROVEMENTS)
          CHANGELOG="${CHANGELOG}"$'\n'
        fi

        if [ ${#FEATURES[@]} -gt 0 ]; then
          CHANGELOG="${CHANGELOG}### üéâ New Features"$'\n\n'
          while IFS= read -r entry; do
            CHANGELOG="${CHANGELOG}${entry}"$'\n'
          done < <(sort_entries FEATURES)
          CHANGELOG="${CHANGELOG}"$'\n'
        fi

        if [ ${#MAINTENANCE[@]} -gt 0 ]; then
          CHANGELOG="${CHANGELOG}### üîß Maintenance"$'\n\n'
          while IFS= read -r entry; do
            CHANGELOG="${CHANGELOG}${entry}"$'\n'
          done < <(sort_entries MAINTENANCE)
          CHANGELOG="${CHANGELOG}"$'\n'
        fi

        if [ ${#OTHER[@]} -gt 0 ]; then
          CHANGELOG="${CHANGELOG}### üì¶ Other"$'\n\n'
          while IFS= read -r entry; do
            CHANGELOG="${CHANGELOG}${entry}"$'\n'
          done < <(sort_entries OTHER)
          CHANGELOG="${CHANGELOG}"$'\n'
        fi

        # If changelog is empty, use a fun message
        if [ -z "$CHANGELOG" ]; then
          CHANGELOG="So much goodness, we lost track! üéâ"
        fi

        echo "Generated changelog:"
        echo "$CHANGELOG"

        echo "CHANGELOG<<EOF" >> $GITHUB_OUTPUT
        echo "$CHANGELOG" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT
      shell: bash
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
